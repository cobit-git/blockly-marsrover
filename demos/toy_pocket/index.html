<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google" value="notranslate">
  <title>Toy Finder</title>
  <link rel="stylesheet" href="style.css">
  <script src="/storage.js"></script>
  <script src="../../dist/blockly_compressed.js"></script>
  <script src="../../dist/blocks_compressed.js"></script>
  <script src="../../dist/javascript_compressed.js"></script>
      <script src="../../build/msg/en.js"></script>

  <script src="http://code.jquery.com/jquery-3.5.1.min.js"></script>
  <!-- Object detecting -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier"></script>
 
  
  <!--<script src="../../blocks/blocks.js"></script>
  <script src="../../blocks/logic.js"></script>
  <script src="../../blocks/loops.js"></script>
  <script src="../../blocks/math.js"></script>
  <script src="../../blocks/text.js"></script>
  <script src="../../blocks/mars_rover.js"></script>
  <script src="../../blocks/lists.js"></script>
  <script src="../../blocks/colour.js"></script>
  <script src="../../blocks/variables.js"></script>
  <script src="../../blocks/procedures.js"></script>
  <script src="../../generators/javascript.js"></script>
  <script src="../../generators/javascript/logic.js"></script>
  <script src="../../generators/javascript/loops.js"></script>
  <script src="../../generators/javascript/math.js"></script>
  <script src="../../generators/javascript/text.js"></script>
  <script src="../../generators/javascript/lists.js"></script>
  <script src="../../generators/javascript/colour.js"></script>
  <script src="../../generators/javascript/variables.js"></script>
  <script src="../../generators/javascript/procedures.js"></script>-->
</head>

<body>
  <!-- Temporal object detecting trigger -->
  <button id ="class-a">Add A</button>
  <button id ="class-b">Add B</button>
  <button id ="class-c">Add C</button>
  
<div id="container">
  <div id="upper-half">
    <div id="connection-container">
      <main id="main" class="main" style="height: 100%; top: 0;">

        <div class="pagetitle">
          <h1>Control Pannel</h1>
        </div><!-- End Page Title -->
    
        <section class="section dashboard">
          <div class="row">
    
            <!-- Left side columns -->
            <div class="col-lg-8">
              <div class="row">
    
                <!-- Card 1 -->
                <div class="col-xxl-4 col-md-6">
                  <div class="card info-card sales-card">
                    <h5 class="card-title">Robot Control <span>|</span></h5>
                      <div>마스로버 컨트롤 채널 선택 : <select id="channles" ></select></div>
                      <div class="grid-container">
                        <div class="grid-child purple">
                          <button class="button" id="open"> Connect  </button>
                        </div>
                        <div class="grid-child green">
                          <button class="button" id="close">Disconnect</button>
                        </div>
                        <div class="grid-child yellow">
                          <img id="connectId" src="disconnected.png">
                        </div>
                    </div>
                  </div>
                </div>

                <!-- Card 2 -->
                <div class="col-xxl-4 col-md-6">
                  <div class="card info-card sales-card">
                    <h5 class="card-title">Camera Connect <span>|</span></h5>
                      <div>카메라 채널 선택 : <select id="cam_channles" ></select></div>
                      <div class="grid-container">
                        <div class="grid-child purple">
                          <button class="button" id="cam_open"> Connect  </button>
                        </div>
                        <div class="grid-child green">
                          <button class="button" id="cam_close">Disconnect</button>
                        </div>
                        <div class="grid-child yellow">
                          <img id="camConnectId" src="disconnected.png">
                        </div>
                    </div>
                  </div>
                </div>
              </div><!-- End Customers Card -->
            </div>
          </div>
        </section>
      </main><!-- End #main -->
    </div>
    <div id="video-container">
      <canvas id="canvas" ></canvas>
    </div>
  </div>
    <button id="trashButton" class="notext" title="...">
      <img src='../../media/1x1.gif' class="trash icon21">
    </button>
    <button id="runButton" class="notext primary" title="...">
      <img src='../../media/1x1.gif' class="run icon21">
    </button>
  <div id="control-container" style="height: 480px; width: 600px;"></div>
    
  </div>

</div>
</body>
<xml xmlns="https://developers.google.com/blockly/xml" id="toolbox" style="display: none">
  <category name="Mars Rover control" colour=200>
    <block type="move_forward">
    </block>
    <block type="rover_stop">
    </block>
    <block type="wait_mili_sec">
    </block>
  </category>
  
  <category name="Logic" colour="%{BKY_LOGIC_HUE}">
    <block type="controls_if"></block>
    <block type="logic_compare"></block>
    <block type="logic_operation"></block>
    <block type="logic_negate"></block>
    <block type="logic_boolean"></block>
  </category>
  <category name="Loops" colour="%{BKY_LOOPS_HUE}">
    <block type="controls_repeat_ext">
      <value name="TIMES">
        <block type="math_number">
          <field name="NUM">10</field>
        </block>
      </value>
    </block>
    <block type="controls_whileUntil"></block>
  </category>
  <category name="Math" colour="%{BKY_MATH_HUE}">
    <block type="math_number">
      <field name="NUM">123</field>
    </block>
    <block type="math_arithmetic"></block>
    <block type="math_single"></block>
  </category>
  <category name="Text" colour="%{BKY_TEXTS_HUE}">
    <block type="text"></block>
    <block type="text_length"></block>
    <block type="text_print"></block>
    <block type="console_print"></block>
  </category>
</xml> 
<script>
          /**
        * Create a namespace for the application.
        */
        var Code = {};
        /**
        * Blockly's main workspace.
        * @type {Blockly.WorkspaceSvg}
        */
        Code.workspace = null;

                /**
        * Load blocks saved on App Engine Storage or in session/local storage.
        * @param {string} defaultXml Text representation of default blocks.
        */
        Code.loadBlocks = function(defaultXml) {
            try {
                var loadOnce = window.sessionStorage.loadOnceBlocks;
            } catch(e) {
                // Firefox sometimes throws a SecurityError when accessing sessionStorage.
                // Restarting Firefox fixes this, so it looks like a bug.
                var loadOnce = null;
            }
            if ('BlocklyStorage' in window && window.location.hash.length > 1) {
                // An href with #key trigers an AJAX call to retrieve saved blocks.
                BlocklyStorage.retrieveXml(window.location.hash.substring(1));
            } else if (loadOnce) {
                // Language switching stores the blocks during the reload.
                delete window.sessionStorage.loadOnceBlocks;
                var xml = Blockly.utils.xml.textToDom(loadOnce);
                Blockly.Xml.domToWorkspace(xml, Code.workspace);
            } else if (defaultXml) {
                // Load the editor with default starting blocks.
                var xml = Blockly.utils.xml.textToDom(defaultXml);
                Blockly.Xml.domToWorkspace(xml, Code.workspace);
            } else if ('BlocklyStorage' in window) {
                // Restore saved blocks in a separate thread so that subsequent
                // initialization is not affected from a failed load.
                window.setTimeout(BlocklyStorage.restoreBlocks, 0);
            }
        };
        /**
        * Bind a function to a button's click event.
        * On touch enabled browsers, ontouchend is treated as equivalent to onclick.
        * @param {!Element|string} el Button element or ID thereof.
        * @param {!Function} func Event handler to bind.
        */
        Code.bindClick = function(el, func) {
        if (typeof el === 'string') {
            el = document.getElementById(el);
        }
        el.addEventListener('click', func, true);
        function touchFunc(e) {
            // Prevent code from being executed twice on touchscreens.
            e.preventDefault();
            func(e);
        }
        el.addEventListener('touchend', touchFunc, true);
        };
        Code.workspace = Blockly.inject('control-container',
            {media: '../../media/',
             toolbox: document.getElementById('toolbox')});
    
        // An href with #key triggers an AJAX call to retrieve saved blocks.
        if ('BlocklyStorage' in window && window.location.hash.length > 1) {
          BlocklyStorage.retrieveXml(window.location.hash.substring(1));
        }

        // Add to reserved word list: Local variables in execution environment (runJS)
        // and the infinite loop detection function.
        Blockly.JavaScript.addReservedWords('code,timeouts,checkTimeout');

        Code.loadBlocks('');

        /**
        * Discard all blocks from the workspace.
        */
        Code.discard = function() {
            var count = Code.workspace.getAllBlocks(false).length;
            if (count < 2 ||
                window.confirm(Blockly.Msg['DELETE_ALL_BLOCKS'].replace('%1', count))) {
                Code.workspace.clear();
                if (window.location.hash) {
                window.location.hash = '';
                }
            }
        };



        /**
        * Execute the user's code.
        * Just a quick and dirty eval.  Catch infinite loops.
        * @param {Event} event Event created from listener bound to the function.
        */
        Code.runJS = function(event) {
            // Prevent code from being executed twice on touchscreens.
            if (event.type === 'touchend') {
            event.preventDefault();
            }
        
            Blockly.JavaScript.INFINITE_LOOP_TRAP = 'checkTimeout();\n';
            var timeouts = 0;
            var checkTimeout = function() {
            if (timeouts++ > 1000000) {
                throw MSG['timeout'];
            }
            };
            var code = Blockly.JavaScript.workspaceToCode(Code.workspace);
            Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
            try {
            eval(code);
            } catch (e) {
            alert(MSG['badCode'].replace('%1', e));
            }
        };

        Code.bindClick('trashButton',
        function() {Code.discard();});
        Code.bindClick('runButton', Code.runJS);
  window.addEventListener("load", function(evt){
    console.log("load");
    let host = "cobot.center"
          let port = 8287;
    //let host = "192.168.0.77";
    //let port = 8277;
    //inputHost.value = host //디폴트
    if (window.location.protocol == 'https:') {
      //inputPort.value = 8276;
      port = 8287;
      //port = 8277
    } else {
      //inputPort.value = 8277;
      port = 8286;
      //port = 8276 
    }
    
    openChannels(host, port);
  });

  async function load_model(){
    console.log('loading moblienet...');
    net = await mobilenet.load();
    console.log('Successfully loaded model');
  }

  const addExample = async classId => {
    // Capture an image from the web camera.
    const img = await webcam.capture();

    // Get the intermediate activation of MobileNet 'conv_preds' and pass that
    // to the KNN classifier.
    const activation = net.infer(img, true);

    // Pass the intermediate activation to the classifier.
    classifier.addExample(activation, classId);

    // Dispose the tensor to release the memory.
    img.dispose();
  };

  // When clicking a button, add an example for that class.
  document.getElementById('class-a').addEventListener('click', () => addExample(0));
  document.getElementById('class-b').addEventListener('click', () => addExample(1));
  document.getElementById('class-c').addEventListener('click', () => addExample(2));

  const classifier = knnClassifier.create();
  load_model();

  var colinkWs;
  // motor control block
  var motor_speed = 0;
  // wait block 
  var wait_time = 0
  
  // Custom event: move_forward 
  const event_move_forward = new Event("move_forward")
  document.addEventListener("move_forward", e => {
    console.log("move forward "+ motor_speed);
    colinkWs.send("AU");
  })

  // Custom event: move_forward 
  const event_rover_stop = new Event("rover_stop")
  document.addEventListener("rover_stop", e => {
    console.log("rover stop");
    colinkWs.send("STOP");
  })

  // Custom event: delay
  const event_rover_delay = new Event("delay")
  document.addEventListener("delay", e => {
    console.log("delay");
    var run = true;
    while(run){
      setInterval(function(){
          run = false;
        },3000);
    }
  }) 
  setInterval(function(){
    alert('hi');
    },3000);
    

  // To disable scroll for arrow keys and space key 
  function disableScroll() { 
    document.body.classList.add("stop-scrolling"); 
  } 
  let stopScroll = disableScroll();
  // To chabge control channel connect image 
  function connImgChange(status){
    if(status == "on"){
      console.log("connImgChang - on");
      $("#connectId").attr("src", "connected.png");
    }else if(status == "off"){
      console.log("connImgChang - off");
      $("#connectId").attr("src", "disconnected.png");
    }		
  }
  // To chabge camera channel connect image 
  function connCamImgChange(status){
    if(status == "on"){
      console.log("connImgChang - on");
      $("#camConnectId").attr("src", "connected.png");
    }else if(status == "off"){
      console.log("connImgChang - off");
      $("#camConnectId").attr("src", "disconnected.png");
    }		
  }

  
  const channelMenu = document.querySelector('#channles')
  let channlesApiUrl = "";
  let saveChannle = []; //api로 받아온 채널 저장.
  let APIOption = {
            mode: "sub",
            channel: "btlb3pjpc98lsdbc0lj0",
            track: "colink",
            mime: 'video/jpeg'
        }

  const camChannelMenu = document.querySelector('#cam_channles')
  let camChannlesApiUrl = "";
  let camSaveChannle = []; //api로 받아온 채널 저장.
  let camAPIOption = {
            mode: "sub",
            channel: "btlb3pjpc98lsdbc0lj0",
            track: "colink",
            mime: 'video/jpeg'
        }


  var ws;
  function openChannels(host, port){
    
    //console.log("Try to open channels...")
    if (window.location.protocol == 'https:') {
      channlesApiUrl = `https://${host}:${port}/monitor/http/cmd?format=json&obj=channel&op=show`;
    } else {
      channlesApiUrl = `http://${host}:${port}/monitor/http/cmd?format=json&obj=channel&op=show`;
    }
    fetch(channlesApiUrl)
      .then(function (response) {
        return response.json()
      })
      .then(function (response) {
        response.map((state, index) => {
          const _option = document.createElement('option')
          option = _option
          saveChannle.push([state.name, state.id])
          option.text = state.name
          option.value = index
          channelMenu.append(option)
          APIOption.channel = saveChannle[0][1]
          if (response[index].state === 1) {
            option.text = option.text + "on using"
          }
        })
      });

    console.log("Try to open cam channels...")
    if (window.location.protocol == 'https:') {
      camChannlesApiUrl = `https://${host}:${port}/monitor/http/cmd?format=json&obj=channel&op=show`;
    } else {
      camChannlesApiUrl = `http://${host}:${port}/monitor/http/cmd?format=json&obj=channel&op=show`;
    }
    console.log(camChannlesApiUrl);
    fetch(camChannlesApiUrl)
      .then(function (response) {
        return response.json()
      })
      .then(function (response) {
        response.map((state, index) => {
          const _option = document.createElement('option')
          option = _option
          camSaveChannle.push([state.name, state.id])
          option.text = state.name
          option.value = index
          camChannelMenu.append(option)
          camAPIOption.channel = camSaveChannle[0][1]
          console.log(camAPIOption.channel)
          if (response[index].state === 1) {
            option.text = option.text + "on using"
          }
        })
      });
    
    // "Open" button onClick 
    document.getElementById("open").onclick = function (evt) {
      //colinkUrl = `ws://192.168.0.77:8276/pang/ws/sub?channel=ca6s906pjh63qlu2ahh0&track=colink`;
      //colinkUrl = `ws://cobot.center:8286/pang/ws/sub?channel=ca6s906pjh63qlu2ahh0&track=colink&mode=bundle`;
      if (window.location.protocol == 'https:') {
                    colinkUrl = `wss://${host}:${port}/pang/ws/${APIOption.mode}?channel=${APIOption.channel}&track=${APIOption.track}&mode=bundle`;
                } else {
                    colinkUrl = `ws://${host}:${port}/pang/ws/${APIOption.mode}?channel=${APIOption.channel}&track=${APIOption.track}&mode=bundle`;
                }
      
      colinkWs = new WebSocket(colinkUrl);
      colinkWs.onopen = function (evt) {
        connImgChange("on");
        console.log(colinkWs);
        if (colinkWs) {
          window.setInterval(() => {

            if (colinkWs != null){
              colinkWs.send("123")
            console.log("heart beat from web")
            }
            
          }, 5000)
          window.addEventListener("gamepadconnected", function (e) {
            console.log("Gamepad connected");
          });

        
          var down = false;

        

          function keyHandler(e){
            const key = event.key;
            
            if (down) return;
            down = true;
            console.log(e.keyCode, e.charCode);
            // Rover control
            if ((e.keyCode === 119) ||(e.keyCode === 87)) { // 'w' or 'W'  
              colinkWs.send("AU");
            }
            if ((e.keyCode === 97) || (e.keyCode === 65)) {  // 'a' or 'A' 
              
            }
            if ((e.keyCode === 115) || (e.keyCode === 83)){  // 's' or 'S'
              colinkWs.send("AD");
            }
            if ((e.keyCode === 100) || (e.keyCode === 68)){  // 'd' or 'D'
             
            }
            if (e.keyCode === 32){  // 'Space'  stop rover 
              colinkWs.send("STOP");
              // Prevent space key to trigger 
              e.preventDefault();
            }
          }

          function keyUpHandler(e){
            down = false;
          }

          document.addEventListener("keydown", keyHandler);
          document.addEventListener('keyup', keyUpHandler);
        }
      };
      colinkWs.onclose = function (evt) {
        connImgChange("off")
        document.removeEventListener("keydown", keyHandler);
        document.removeEventListener('keyup', keyUpHandler);
        colinkWs = null;
      };

      colinkWs.onmessage = function (evt) {
        //console.log(evt.data);
        if (typeof evt.data == "object") {
          draw(evt.data);
        } else if (typeof evt.data == "string") {
          // mimetype.innerHTML = `mime.Type = ${evt.data}`;
        } else {
          //print("RESPONSE: " + evt.data);
        }
      };
      colinkWs.onerror = function (evt) {
        
      };
      return false;
    };
    // "Close" button onClick 
    document.getElementById("close").onclick = function (evt) {
                if (!colinkWs) {
                    return false;
                }
                if (colinkWs) {
        connImgChange("off")
        document.removeEventListener("keydown", keyHandler);
        document.removeEventListener('keyup', keyUpHandler);
                    colinkWs.close();
                }
                return false;
            };
    document.getElementById("cam_close").onclick = function(evt) {
      if (!ws) {
        return false;
      }
      connCamImgChange("off")
      ws.close();
      return false;
    };
    channelMenu.onchange = function (e) { //채널을 클릭했을 떄.
                APIOption.channel = saveChannle[this.value][1];
      console.log(APIOption.channel, "control channel");

            }
    camChannelMenu.onchange = function (e) { //채널을 클릭했을 떄.
                camAPIOption.channel = camSaveChannle[this.value][1];
      console.log(camAPIOption.channel, "cam channel");

            }
    document.getElementById("cam_open").onclick = function(evt) {
      if (window.location.protocol == 'https:') {
        wsurl = `wss://${host}:${port}/pang/ws/${camAPIOption.mode}?channel=${camAPIOption.channel}&track=<label>`;
      } else {
        wsurl = `ws://${host}:${port}/pang/ws/${camAPIOption.mode}?channel=${camAPIOption.channel}&track=<label>`;
      }
      
      ws = new WebSocket(wsurl);
      ws.binaryType = 'arraybuffer';

      ws.onopen = function(evt) {
        connCamImgChange("on");
        console.log(ws);
      }
      ws.onclose = function(evt) {
        ws = null;
        connCamImgChange("off");
      }
      ws.onmessage = function(evt) {
        // console.log(typeof evt.data)
        if (typeof evt.data == "object") {
          draw(evt.data)
        } else if (typeof evt.data == "string") {
          //mimetype.innerHTML = `mime.Type = ${evt.data}`
        } else {
          //print("RESPONSE: " + evt.data);
        }
      }
      ws.onerror = function(evt) {
        //print("ERROR: " + evt.data);
      }
      return false;
    };
    
  } // End of openChannels()
  
  var canvas = document.getElementById('canvas');
  var ctx = canvas.getContext('2d');
    let imageSize = {
      width : 320,
      height : 240
  }
  window.onload = () => {
      canvas.style.width = 320;
      canvas.style.height = 240;
  }
  function draw(data) {
    var arrayBufferView = new Uint8Array( data );
    var blob = new Blob( [ arrayBufferView ], { type: "image/jpeg" } );
    var urlCreator = window.URL || window.webkitURL;
    var imageUrl = urlCreator.createObjectURL( blob );

    var img  = new Image();

    var imageData = imageUrl  //'data:image/jpeg;base64,' + Json;
    img.src = imageData;
    //console.log(blob.size)
    if (blob.size > 20000 && blob.size < 75000) {
      imageSize.width = 800;
      imageSize.height = 600;
    }
    if (blob.size > 75000 && blob.size < 150000) { //HD
      imageSize.width = 1280;
      imageSize.height = 720;
    }
    if (blob.size > 150000 && blob.size < 190000) { //FHD
      imageSize.width = 1920;
      imageSize.height = 1080;
    }
    if (blob.size > 200000 && blob.size < 300000) { //QHD
      imageSize.width = 2560;
      imageSize.height = 1440;
    }

    img.onload = function(){
      canvas.style.width = imageSize.width*2;
      canvas.style.height = imageSize.height*2;
      canvas.width = imageSize.width;
      canvas.height = imageSize.height;
      
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      // move to the center of the canvas
      //ctx.translate(canvas.width/2,canvas.height/2);

      // rotate the canvas to the specified degrees
      //tx.rotate(270*Math.PI/180);
      ctx.drawImage(img,0, 0,imageSize.width,imageSize.height);
      ctx.restore();
    };
      }  // end of draw()
</script>
</html>
